<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JARVIS: Celestial Apex</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; touch-action: none; }
        #input_video { position: absolute; width: 100vw; height: 100vh; object-fit: cover; transform: scaleX(-1); z-index: -1; }
        #biometric_canvas { position: absolute; width: 100vw; height: 100vh; z-index: 5; transform: scaleX(-1); pointer-events: none; }
        #three_canvas { position: absolute; top: 0; left: 0; z-index: 10; pointer-events: none; }
        #status { 
            position: absolute; top: 20px; left: 20px; z-index: 100;
            color: #00f0ff; font-family: 'Courier New', monospace; font-weight: bold;
            text-shadow: 0 0 10px #00f0ff; border-left: 3px solid #00f0ff; padding-left: 10px; font-size: 12px;
        }
        #resize_ui {
            position: absolute; top: 20px; right: 20px; z-index: 100;
            color: #ff3333; font-family: 'Courier New', monospace; font-size: 14px;
            padding: 8px; border: 1px solid #ff3333; display: none;
            background: rgba(0,0,0,0.5); text-shadow: 0 0 5px #ff3333;
        }
    </style>
</head>
<body>
    <div id="status">INITIATING CELESTIAL OVERRIDE...</div>
    <div id="resize_ui">RESIZE ACTIVATED</div>
    <video id="input_video" autoplay playsinline></video>
    <canvas id="biometric_canvas"></canvas>
    <canvas id="three_canvas"></canvas>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const status = document.getElementById('status');
        const resizeUI = document.getElementById('resize_ui');
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('biometric_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        
        let rotationMomentum = 0.0015;
        let prevHand2X = null;
        let activeHandLabel = null;
        let pinchStartTime = null;
        let isResizeMode = false;
        let currentScale = 1.0;
        let sunAngle = 0; 

        // 1. ENGINE SETUP (Responsive)
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ 
            canvas: document.getElementById('three_canvas'),
            antialias: true, alpha: true, logarithmicDepthBuffer: true
        });

        function updateScreen() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            renderer.setSize(w, h);
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
            window.isMobile = w < h;
            window.baseScale = isMobile ? 0.60 : 1.0; // Responsive Earth size
        }
        updateScreen();
        window.addEventListener('resize', updateScreen);

        const vFOV = (camera.fov * Math.PI) / 180;
        const visibleHeight = 2 * Math.tan(vFOV / 2) * 10;

        // 2. CELESTIAL ASSETS (Ultra Graphics)
        const earthGroup = new THREE.Group();
        earthGroup.visible = false; 
        scene.add(earthGroup);

        const loader = new THREE.TextureLoader();
        
        // --- SHADER: Day/Night Blend ---
        const earthShaderMat = new THREE.ShaderMaterial({
            uniforms: {
                dayTex: { value: loader.load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg') },
                nightTex: { value: loader.load('https://threejs.org/examples/textures/planets/earth_night_2048.jpg') },
                sunDir: { value: new THREE.Vector3(1, 0.5, 1).normalize() } 
            },
            vertexShader: `
                varying vec2 vUv;
                varying vec3 vNormal;
                void main() {
                    vUv = uv;
                    vNormal = normalize(normalMatrix * normal);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D dayTex;
                uniform sampler2D nightTex;
                uniform vec3 sunDir;
                varying vec2 vUv;
                varying vec3 vNormal;
                void main() {
                    vec3 dayColor = texture2D(dayTex, vUv).rgb;
                    vec3 nightColor = texture2D(nightTex, vUv).rgb;
                    float intensity = dot(vNormal, sunDir);
                    float mixAmount = smoothstep(-0.2, 0.2, intensity);
                    gl_FragColor = vec4(mix(nightColor, dayColor, mixAmount), 1.0);
                }
            `
        });

        const earth = new THREE.Mesh(new THREE.SphereGeometry(2.4, 256, 256), earthShaderMat);
        earthGroup.add(earth);

        const clouds = new THREE.Mesh(
            new THREE.SphereGeometry(2.47, 128, 128),
            new THREE.MeshPhongMaterial({ map: loader.load('https://threejs.org/examples/textures/planets/earth_clouds_1024.png'), transparent: true, opacity: 0.8 })
        );
        earthGroup.add(clouds);

        // --- THE MOON ---
        const moonGroup = new THREE.Group();
        earthGroup.add(moonGroup);
        const moonMat = new THREE.MeshBasicMaterial({ map: loader.load('https://threejs.org/examples/textures/planets/moon_1024.jpg'), color: 0xffffff });
        const moon = new THREE.Mesh(new THREE.SphereGeometry(0.55, 64, 64), moonMat);
        moon.position.set(4.0, 0, 0); 
        moonGroup.add(moon);

        scene.add(new THREE.AmbientLight(0xffffff, 0.1));
        camera.position.z = 10;

        // 3. APEX BIOMETRICS (Glow Finger Tracing)
        function onResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                let h1 = null, h2 = null;
                results.multiHandLandmarks.forEach((landmarks, index) => {
                    const label = results.multiHandedness[index].label;
                    
                    // --- NEON GLOW FINGER TRACING ---
                    canvasCtx.shadowBlur = 10;
                    canvasCtx.shadowColor = "#00f0ff";
                    drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00f0ff', lineWidth: 2});
                    drawLandmarks(canvasCtx, landmarks, {color: '#FFFFFF', fillColor: '#00f0ff', radius: isMobile ? 2 : 3});
                    
                    if (activeHandLabel === null) activeHandLabel = label;
                    if (label === activeHandLabel) h1 = landmarks;
                    else h2 = landmarks;
                });

                if (h1) {
                    const wrist = h1[0], indexTip = h1[8], mid = h1[9];
                    const distToFist = Math.hypot(indexTip.x - wrist.x, indexTip.y - wrist.y);
                    if (distToFist > 0.18) {
                        earthGroup.visible = true;
                        const curVisWidth = visibleHeight * (window.innerWidth / window.innerHeight);
                        const tx = (mid.x - 0.5) * -curVisWidth;
                        const ty = (mid.y - 0.5) * -visibleHeight;
                        earthGroup.position.lerp(new THREE.Vector3(tx, ty + (isMobile ? 2.5 : 4.5), 0), 0.15);
                        if (!isResizeMode) earthGroup.scale.lerp(new THREE.Vector3(baseScale, baseScale, baseScale), 0.1);
                    } else { earthGroup.visible = false; }
                }

                if (h2 && earthGroup.visible) {
                    const thumbTip = h2[4], indexTip = h2[8], mid2 = h2[9];
                    const rawDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
                    
                    if (rawDist < 0.045) {
                        if (pinchStartTime === null) pinchStartTime = Date.now();
                        if (Date.now() - pinchStartTime > 1000) {
                            isResizeMode = true;
                            resizeUI.style.display = 'block';
                        }
                    } else if (!isResizeMode) pinchStartTime = null;

                    if (isResizeMode) {
                        currentScale = THREE.MathUtils.lerp(currentScale, rawDist * (isMobile ? 12.0 : 10.0), 0.1);
                        earthGroup.scale.setScalar(THREE.MathUtils.clamp(currentScale, 0.2, 4.0));
                    } else {
                        const curX = mid2.x;
                        if (prevHand2X !== null) {
                            const deltaX = curX - prevHand2X;
                            if (Math.abs(deltaX) > 0.015) rotationMomentum += deltaX * 0.45;
                        }
                        prevHand2X = curX;
                    }
                } else {
                    isResizeMode = false; pinchStartTime = null; resizeUI.style.display = 'none';
                    prevHand2X = null;
                }
            } else { earthGroup.visible = false; activeHandLabel = null; }
            canvasCtx.restore();
        }

        const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
        hands.setOptions({ maxNumHands: 2, modelComplexity: isMobile ? 0 : 1, minDetectionConfidence: 0.8, minTrackingConfidence: 0.8 });
        hands.onResults(onResults);

        new Camera(videoElement, {
            onFrame: async () => { 
                canvasElement.width = videoElement.videoWidth;
                canvasElement.height = videoElement.videoHeight;
                await hands.send({image: videoElement}); 
            }, width: 1280, height: 720
        }).start();

        function animate() {
            requestAnimationFrame(animate);
            sunAngle += 0.003; 
            earth.material.uniforms.sunDir.value.set(Math.sin(sunAngle) * 5, 2, Math.cos(sunAngle) * 5).normalize();
            earth.rotation.y += rotationMomentum;
            clouds.rotation.y += rotationMomentum * 1.15;
            moonGroup.rotation.y += rotationMomentum * 2.0; 
            rotationMomentum *= 0.985;
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
