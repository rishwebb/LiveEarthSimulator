<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>JARVIS: Hyper-Apex AR</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; }
        #input_video { position: absolute; width: 100vw; height: 100vh; object-fit: cover; transform: scaleX(-1); z-index: -1; }
        #biometric_canvas { position: absolute; width: 100vw; height: 100vh; z-index: 5; transform: scaleX(-1); pointer-events: none; }
        #three_canvas { position: absolute; top: 0; left: 0; z-index: 10; pointer-events: none; }
        #status { 
            position: absolute; top: 40px; left: 40px; z-index: 100;
            color: #00f0ff; font-family: 'Courier New', monospace; font-weight: bold;
            text-shadow: 0 0 20px #00f0ff; border-left: 5px solid #00f0ff; padding-left: 20px;
        }
        #resize_ui {
            position: absolute; top: 40px; right: 40px; z-index: 100;
            color: #ff3333; font-family: 'Courier New', monospace; font-size: 18px;
            padding: 10px; border: 2px solid #ff3333; display: none;
            background: rgba(0,0,0,0.5); text-shadow: 0 0 10px #ff3333;
        }
    </style>
</head>
<body>
    <div id="status">INITIATING HYPER-APEX OVERRIDE...</div>
    <div id="resize_ui">RESIZE ACTIVATED</div>
    <video id="input_video" autoplay playsinline></video>
    <canvas id="biometric_canvas"></canvas>
    <canvas id="three_canvas"></canvas>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const status = document.getElementById('status');
        const resizeUI = document.getElementById('resize_ui');
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('biometric_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        
        let rotationMomentum = 0.0015;
        let prevHand2X = null;
        let activeHandLabel = null;
        
        let pinchStartTime = null;
        let isResizeMode = false;
        let currentScale = 1.0;

        // 1. ENGINE SETUP
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ 
            canvas: document.getElementById('three_canvas'),
            antialias: true, alpha: true, logarithmicDepthBuffer: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio > 1 ? 2 : 1);

        const vFOV = (camera.fov * Math.PI) / 180;
        const visibleHeight = 2 * Math.tan(vFOV / 2) * 10;
        const visibleWidth = visibleHeight * camera.aspect;

        // 2. ULTRA-HD ASSETS
        const earthGroup = new THREE.Group();
        earthGroup.visible = false; 
        scene.add(earthGroup);

        const loader = new THREE.TextureLoader();
        const earthMat = new THREE.MeshPhongMaterial({ 
            map: loader.load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg'),
            specularMap: loader.load('https://threejs.org/examples/textures/planets/earth_specular_2048.jpg'),
            bumpMap: loader.load('https://threejs.org/examples/textures/planets/earth_normal_2048.jpg'),
            bumpScale: 0.08, shininess: 50 
        });
        const earth = new THREE.Mesh(new THREE.SphereGeometry(2.4, 256, 256), earthMat);
        earthGroup.add(earth);

        const clouds = new THREE.Mesh(
            new THREE.SphereGeometry(2.47, 128, 128),
            new THREE.MeshPhongMaterial({ map: loader.load('https://threejs.org/examples/textures/planets/earth_clouds_1024.png'), transparent: true, opacity: 0.85 })
        );
        earthGroup.add(clouds);

        scene.add(new THREE.AmbientLight(0xffffff, 0.45));
        const sun = new THREE.DirectionalLight(0xffffff, 2.2);
        sun.position.set(5, 3, 5);
        scene.add(sun);
        camera.position.z = 10;

        // 3. PRECISION GESTURE LOGIC
        function onResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                let h1 = null, h2 = null;

                results.multiHandLandmarks.forEach((landmarks, index) => {
                    const label = results.multiHandedness[index].label;
                    drawLandmarks(canvasCtx, landmarks, {color: '#FFFFFF', lineWidth: 2, radius: 4});
                    
                    if (activeHandLabel === null) activeHandLabel = label;
                    if (label === activeHandLabel) h1 = landmarks;
                    else h2 = landmarks;
                });

                if (h1) {
                    const wrist = h1[0], indexTip = h1[8], mid = h1[9];
                    const distToFist = Math.hypot(indexTip.x - wrist.x, indexTip.y - wrist.y);
                    
                    if (distToFist > 0.18) {
                        earthGroup.visible = true;
                        status.innerText = "BIOMETRIC LOCK: 100%";
                        const tx = (mid.x - 0.5) * -visibleWidth;
                        const ty = (mid.y - 0.5) * -visibleHeight;
                        // Distance halved: Offset changed from 6.0 to 3.0
                        earthGroup.position.lerp(new THREE.Vector3(tx, ty + 3.0, 0), 0.15);
                    } else {
                        earthGroup.visible = false;
                        status.innerText = "ANCHOR FIST: STANDBY";
                    }
                }

                if (h2 && earthGroup.visible) {
                    const thumbTip = h2[4], indexTip = h2[8], mid2 = h2[9];
                    const rawDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
                    
                    // 1 SEC PINCH ACTIVATION
                    if (rawDist < 0.04) {
                        if (pinchStartTime === null) pinchStartTime = Date.now();
                        if (Date.now() - pinchStartTime > 1000) {
                            isResizeMode = true;
                            resizeUI.style.display = 'block';
                            resizeUI.style.color = '#00f0ff';
                            resizeUI.style.borderColor = '#00f0ff';
                        }
                    } else if (!isResizeMode) {
                        pinchStartTime = null;
                    }

                    // RESIZE MODE: Disable Slapping here
                    if (isResizeMode) {
                        currentScale = THREE.MathUtils.lerp(currentScale, rawDist * 10.0, 0.1);
                        earthGroup.scale.setScalar(THREE.MathUtils.clamp(currentScale, 0.2, 3.8));
                    } else {
                        // SLAP MODE: Only works if not pinching
                        const curX = mid2.x;
                        if (prevHand2X !== null) {
                            const deltaX = curX - prevHand2X;
                            // Strict velocity check to distinguish from a slow pinch movement
                            if (Math.abs(deltaX) > 0.015) rotationMomentum += deltaX * 0.45;
                        }
                        prevHand2X = curX;
                    }
                } else {
                    isResizeMode = false;
                    pinchStartTime = null;
                    resizeUI.style.display = 'none';
                    prevHand2X = null;
                    earthGroup.scale.lerp(new THREE.Vector3(1,1,1), 0.08);
                }
            } else {
                earthGroup.visible = false;
                activeHandLabel = null;
                status.innerText = "SEARCHING...";
            }
            canvasCtx.restore();
        }

        const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.85, minTrackingConfidence: 0.85 });
        hands.onResults(onResults);

        new Camera(videoElement, {
            onFrame: async () => { 
                canvasElement.width = videoElement.videoWidth;
                canvasElement.height = videoElement.videoHeight;
                await hands.send({image: videoElement}); 
            }, width: 1280, height: 720
        }).start();

        function animate() {
            requestAnimationFrame(animate);
            earth.rotation.y += rotationMomentum;
            clouds.rotation.y += rotationMomentum * 1.15;
            rotationMomentum *= 0.985;
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
